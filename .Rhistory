ADX_AAPL[i,3] <- "SELL"
}else{
ADX_AAPL[i,4] <- "BUY"
}
}
for (i in 1:length(ADX_AAPL)){
ifelse((ADX_AAPL[i,2] > ADX_AAPL[i,1])&(ADX_AAPL[i,4] > 14),ADX_AAPL[i,3] <- "SELL",ADX_AAPL[i,4] <- "BUY")
}
ADX_AAPL[1,2]
ADX_AAPL[3,2]
length(ADX_AAPL)
ADX_AAPL[16020,2]
ADX_AAPL[16019,2]
ADX_AAPL[40,2]
ADX_AAPL[10000,2]
tail(ADX_AAPL)
ADX_AAPL <- ADX(AAPL,n=14)
for (i in 1:length(ADX_AAPL)){
ifelse((ADX_AAPL[i,2] > ADX_AAPL[i,1])&(ADX_AAPL[i,4] > 14),ADX_AAPL[i,3] <- "SELL",ADX_AAPL[i,3] <- "BUY")
}
length(ADX_AAPL[1,])
length(ADX_AAPL[,1])
for (i in 1:length(ADX_AAPL[,1])){
ifelse((ADX_AAPL[i,2] > ADX_AAPL[i,1])&(ADX_AAPL[i,4] > 14),ADX_AAPL[i,3] <- "SELL",ADX_AAPL[i,3] <- "BUY")
}
ADX_AAPL
View(ADX_AAPL)
for (i in 1:length(ADX_AAPL[,1])){
ifelse((ADX_AAPL[i,2] > ADX_AAPL[i,1])&(ADX_AAPL[i,4] > 14),ADX_AAPL[i,3] <- "BEARISH",ADX_AAPL[i,3] <- "BULLISH")
}
View(ADX_AAPL)
cbind(AAPL_price,AAPL_return,)
cbind(AAPL_price,AAPL_return)
View(ADX_AAPL)
ADX_AAPL <- ADX_AAPL[,-(1,2)]
ADX_AAPL <- ADX_AAPL[,-1]
ADX_AAPL <- ADX_AAPL[,-2]
ADX_AAPL <- ADX(AAPL,n=14)
#transforme the number in signal
for (i in 1:length(ADX_AAPL[,1])){
ifelse((ADX_AAPL[i,2] > ADX_AAPL[i,1])&(ADX_AAPL[i,4] > 14),ADX_AAPL[i,3] <- "BEARISH",ADX_AAPL[i,3] <- "BULLISH")
}
ADX_AAPL <- ADX_AAPL[,-(1:2)]
View(ADX_AAPL)
output<- cbind(AAPL_price,AAPL_return)
output<-cbind(output,ADX_AAPL)
View(output)
View(ADX_AAPL)
output<- cbind(AAPL_price,AAPL_return)
View(output)
output[,3] <- ADX_AAPL[,1]
length(ADX_AAPL[,1])
length(output[,1])
output[,3] <- 0
output <- matrix(nrow=50000,ncol=10)
output[,1] <- AAPL_price[,1]
output <- matrix(nrow=4005,ncol=10)
output[,1] <- AAPL_price[,1]
output[,2] <- AAPL_return[,1]
output[,3] <- ADX_AAPL[,1]
output[,4] <- ADX_AAPL[,2]
View(output)
SMA(AAPL, n=10)
EMA(AAPL, n=10, wilder=FALSE, ratio=NULL)
WMA(AAPL, n=10, wts=1:n)
DEMA(AAPL, n=10, v=1, wilder=FALSE, ratio=NULL)
EVWMA(AAPL_price, volume, n=10)
ZLEMA(AAPL, n=10, ratio=NULL)
VWMA(AAPL_price, volume, n=10)
VWAP(AAPL_price, volume, n=10)
head(SMA(AAPL, n=10),10)
head(EMA(AAPL, n=10, wilder=FALSE, ratio=NULL),10)
head(WMA(AAPL, n=10, wts=1:n),10)
head(DEMA(AAPL, n=10, v=1, wilder=FALSE, ratio=NULL),10)
head(EVWMA(AAPL_price, AAPL$AAPL.Volume, n=10),10)
head(ZLEMA(AAPL, n=10, ratio=NULL),10)
head(VWMA(AAPL_price, AAPL$AAPL.Volume, n=10),10)
head(VWAP(AAPL_price, AAPL$AAPL.Volume, n=10),10)
Sys.Date()$year
temp <- Sys.Date()
temp
temp$year
as.Date(temp)
temp$year
temp.year
year(temp)
install.packages("tm")
install.packages("XML")
corpus <- WebCorpus(GoogleFinanceSource("AAPL"))
library(tm)
library(XML)
library(c(tm,XML))
library(c("tm","XML"))
require(c("tm","XML"))
corpus <- WebCorpus(GoogleFinanceSource("AAPL"))
install.packages(tm.plugin.webmining)
install.packages("tm.plugin.webmining")
install.packages("tm.plugin.sentiment")
corpus <- WebCorpus(GoogleFinanceSource("AAPL"))
library(tm.plugin.sentiment)
install.packages("tm.plugin.sentiment")
library(devtools)
install_github("mannau/tm.plugin.sentiment")
library(tm)
library(XML)
library(tm.plugin.webmining)
library(tm.plugin.sentiment)
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME=C:/Program Files/Java/jdk1.8.0_05/bin")
Sys.setenv(JAVA_HOME="C:/Program Files/Java/jdk1.8.0_05/bin")
library(tm.plugin.webmining)
install_github("mannau/tm.plugin.webmining")
remove.packages("tm.plugin.webmining")
install_github("mannau/tm.plugin.webmining")
library(tm.plugin.webmining)
install.packages("tm.plugin.webmining")
library(tm.plugin.webmining)
library(h2o)
h2o.init
h2o.init()
library(h2o)
local <- h2o.init()
h2o.shutdown(prompt=FALSE)
local <- h2o.init(nthreads = -1)
h2o.shutdown(prompt=FALSE)
library(tm)
library(XML)
library(tm.plugin.webmining)
library(tm.plugin.sentiment)
library(tm.plugin.sentiment)
library(tm.plugin.webmining)
install.packages(rJava)
install.packages("rJava")
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME="path/java/home")
library(tm.plugin.webmining)
h2o.init()
Sys.setenv(JAVA_HOME="C:\Program Files\Java\jdk1.8.0_31\bin")
Sys.setenv(JAVA_HOME="C:/Program Files/Java/jdk1.8.0_31/bin")
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME="C:/Program Files/Java/jre1.8.0_31/bin")
library(tm.plugin.webmining)
h2o.init()
install.packages("tm.plugin.sentiment", repos="http://R-Forge.R-project.org")
install.packages("tm.plugin.sentiment", repos = "http://R-Forge.R-project.org")
library(tm.plugin.webmining)
install.packages("rJava")
Sys.setenv(JAVA_HOME="C:/Users/PedroHenrique/Documents/R/win-library/3.2/rJava/libs/x64")
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME="C:/Users/PedroHenrique/Documents/R/win-library/3.2/rJava/libs/i386")
library(tm.plugin.webmining)
version
Sys.setenv(JAVA_HOME="C:/Program Files (x86)/Java/jre1.8.0_45/bin")
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME="C:/Program Files (x86)/Java/jre1.8.0_45/bin")
library(tm.plugin.webmining)
library(h2o)
h2o.ini(nthreads = -1)
h2o.init(nthreads = -1)
h2o.shutdown(prompt = FALSE)
library(tm)
library(XML)
library(tm.plugin.webmining)
remove.packages("rJava")
install.packages("rJava")
library(tm.plugin.webmining)
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files (x86)\\Java\\jdk1.8.0_66\\bin') # for 64-bit version
library(rJava)
library(tm.plugin.webmining)
Sys.setenv(JAVA_HOME="C:/Program Files (x86)/Java/jdk1.8.0_66/bin") # for 64-bit version
library(tm.plugin.webmining)
library(tm.plugin.webmining)
library(rJava)
find.java <- function() {
for (root in c("HLM", "HCU")) for (key in c("Software\\JavaSoft\\Java Runtime Environment",
"Software\\JavaSoft\\Java Development Kit")) {
hive <- try(utils::readRegistry(key, root, 2),
silent = TRUE)
if (!inherits(hive, "try-error"))
return(hive)
}
hive
}
find.java()
Sys.setenv(JAVA_HOME='C:\\Program Files (x86)\\Java\\jdk1.8.0_66')
find.java()
library(h2o)
h2o.init(nthreads=-1)
h2o.shutdown(prompt=FALSE)
library(rJava)
library(tm)
library(XML)
library(tm.plugin.webmining)
library(tm.plugin.sentiment)
corpus <- WebCorpus(GoogleFinanceSource("AAPL"))
corpus
install.packages("openNLP")
library(openNLP)
stock <- "AAPL"
sentences <- sentDetect(corpus)
library(openNLP)
sentences <- sentDetect(corpus)
sentences <- sent_detect(corpus)
library(qdap)
library("qdap")
install.packages("qdap")
library(qdap)
sentences <- sent_detect(corpus)
filteredSentences <- setences[grepl(stock,setences)]
filteredSentences <- sentences[grepl(stock,sentences)]
filteredSentences
sapply(corpus,FUN=function(x){attr,"Heading"})
sapply(corpus,FUN=function(x){attr(x,"Heading")})
stock <- "PCLN"
stock <- "PCLN"
des <- sapply(corpus,FUN=function(x){attr(x,"Description")})
filteredDesc <- desc[grepl(stock,desc)]
desc <- sapply(corpus,FUN=function(x){attr(x,"Description")})
filteredDesc <- desc[grepl(stock,desc)]
rm(des)
install.packages("tm.plugin.tags")
install.packages("tm.plugin.tag", repos="http://R-Forge.R-project.org",dependencies=TRUE)
install.packages("tm.plugin.tags", repos="http://R-Forge.R-project.org",dependencies=TRUE)
install.packages("tm.plugin.tags", repos = "http://datacube.wu.ac.at", type = "source")
require(quantmod)
require(igraph)
##################################################### HW5 - FE 582 ###########################################################
#Author: Pedro Sa
#############################################################################################################################
#- Download daily price data of Dow 30 index stocks (Jan1, 2012 - Dec31, 2012), and calculate daily return.
#- Calculate correlation matrix (result should be a 30 x 30 matrix )
#- Use the matrix to draw a network with nodes and edges. Each node should have stock ticker as label on it.
require(quantmod)
require(igraph)
ticker <- c(
"AAPL",
"AXP",
"BA",
"CAT",
"CSCO",
"CVX",
"DD",
"DIS",
"GE",
"GS",
"HD",
"IBM",
"INTC",
"JNJ",
"JPM",
"KO",
"MCD",
"MMM",
"MRK",
"MSFT",
"NKE",
"PFE",
"PG",
"TRV",
"UNH",
"UTX",
"V",
"VZ",
"WMT",
"XOM"
)
start_date <- "2012/01/01"
end_date <- "2012/12/31"
Stocks <- lapply(1:30, function(i) {
as.xts(dailyReturn(na.omit(getSymbols(ticker[i], from=start_date,to=end_date, auto.assign=FALSE,warnings = FALSE))))
}
)
Stocks<-do.call(cbind,Stocks)
Stocks <- as.data.frame(Stocks)
colnames(Stocks) <- ticker
#calculate the correlation matrix
cor_matrix <- cor(Stocks)
#create the network
net<-graph.adjacency(cor_matrix,mode="undirected",
weighted=TRUE,
diag=FALSE)
E(net)$length<- E(net)$weight
E(net)$label<- round(E(net)$weight)
plot(net)
##################################################### HW4 - FE 582 ###########################################################
#Author: Pedro Sa
#############################################################################################################################
#For stocks in 2 different industries (listed below):
#  Energy: APA, COG, CVX, MUR, SE
#Finance: BAC, BLK, COF, GS, MET
#- Use the historical daily price data (Jan 1, 2014 - Dec 31, 2014)
#- Calculate daily return
#- Use k-means clustering makes them into 2 groups.
#- Compare the cluster from kmeans and real industrial label.
#- Brief analyze the result (whether labels are the same? Is there any different?)
#loads the library
require(quantmod)
require(stats)
tickers <- c("APA","COG","CVX","MUR","SE","BAC","BLK","COF","GS","MET")
#iniciates the dates
start_date <- "2014/01/01"
end_date <- "2015/01/01"
stocks_rtn <- lapply(1:10, function(i) {
as.xts(dailyReturn(na.omit(getSymbols(tickers[i], from=start_date,to=end_date, auto.assign=FALSE,warnings = FALSE))))
}
)
stocks_rtn<-do.call(cbind,stocks_rtn)
colnames(stocks_rtn) <-tickers
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10),
stock=stocks_rtn
)
mean(stocks_rtn)
mean(stocks_rtn[,1])
mean(stocks_rtn[,2])
stocks_mean <- laaply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_rtn <- lapply(1:10, function(i) {
as.xts(dailyReturn(na.omit(getSymbols(tickers[i], from=start_date,to=end_date, auto.assign=FALSE,warnings = FALSE))))
}
)
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
mean(stocks_rtn[,1])
mean(stocks_rtn[,1])
##################################################### HW4 - FE 582 ###########################################################
#Author: Pedro Sa
#############################################################################################################################
#For stocks in 2 different industries (listed below):
#  Energy: APA, COG, CVX, MUR, SE
#Finance: BAC, BLK, COF, GS, MET
#- Use the historical daily price data (Jan 1, 2014 - Dec 31, 2014)
#- Calculate daily return
#- Use k-means clustering makes them into 2 groups.
#- Compare the cluster from kmeans and real industrial label.
#- Brief analyze the result (whether labels are the same? Is there any different?)
#loads the library
require(quantmod)
require(stats)
tickers <- c("APA","COG","CVX","MUR","SE","BAC","BLK","COF","GS","MET")
#iniciates the dates
start_date <- "2014/01/01"
end_date <- "2015/01/01"
stocks_rtn <- lapply(1:10, function(i) {
as.xts(dailyReturn(na.omit(getSymbols(tickers[i], from=start_date,to=end_date, auto.assign=FALSE,warnings = FALSE))))
}
)
stocks_rtn<-do.call(cbind,stocks_rtn)
colnames(stocks_rtn) <-tickers
mean(stocks_rtn[,1])
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_mean
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10),
stock=stocks_mean
)
View(group)
km <- cclust(cbind(group$x,group$stock),centers = 2, method = "kmeans")
require(cclust)
install.packages("cclust")
require(cclust)
km <- cclust(cbind(group$x,group$stock),centers = 2, method = "kmeans")
View(group)
View(group)
colnames(group) <- c("g","x","APA","COG","CVX","MUR","SE","BAC","BLK","COF","GS","MET")
View(group)
stocks_mean
as.data.frame(stocks_mean)
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_mean <- as.data.frame(stocks_mean)
colnames(stocks_mean) <- tickers
View(stocks_mean)
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10),
stock=stocks_mean
)
View(group)
require(optimbase)
install.packages("optimbase")
require(optimbase)
stocks_means <- transpose(stocks_mean)
stocks_mean <- as.matrix(stocks_mena)
stocks_mean <- as.matrix(stocks_mean)
stocks_means <- transpose(stocks_mean)
stocks_mean <- as.data.frame(stocks_mean)
View(stocks_mean)
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_mean <- as.data.frame(stocks_mean)
colnames(stocks_mean) <- tickers
View(stocks_mean)
stocks_mean <- as.matrix(stocks_mean)
stocks_means <- transpose(stocks_mean)
stocks_means
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10),
stock=stocks_mean
)
View(group)
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10)
)
View(group)
group <- cbind(group,stocks_means)
View(group)
km <- cclust(cbind(group$x,group$stock_means),centers = 2, method = "kmeans")
View(stocks_mean)
View(group)
View(group)
km <- cclust(group[,(2:3)],centers = 2, method = "kmeans")
View(group)
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_mean <- as.data.frame(stocks_mean)
colnames(stocks_mean) <- tickers
stocks_mean <- as.matrix(stocks_mean)
stocks_means <- transpose(stocks_mean)
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10)
)
group <- as.data.frame(cbind(group,stocks_means))
View(group)
km <- cclust(group[,(2:3)],centers = 2, method = "kmeans")
stocks_mean[1]
stocks_mean[2]
##################################################### HW4 - FE 582 ###########################################################
#Author: Pedro Sa
#############################################################################################################################
#For stocks in 2 different industries (listed below):
#  Energy: APA, COG, CVX, MUR, SE
#Finance: BAC, BLK, COF, GS, MET
#- Use the historical daily price data (Jan 1, 2014 - Dec 31, 2014)
#- Calculate daily return
#- Use k-means clustering makes them into 2 groups.
#- Compare the cluster from kmeans and real industrial label.
#- Brief analyze the result (whether labels are the same? Is there any different?)
#loads the library
require(quantmod)
require(cclust)
require(optimbase)
tickers <- c("APA","COG","CVX","MUR","SE","BAC","BLK","COF","GS","MET")
#iniciates the dates
start_date <- "2014/01/01"
end_date <- "2015/01/01"
stocks_rtn <- lapply(1:10, function(i) {
as.xts(dailyReturn(na.omit(getSymbols(tickers[i], from=start_date,to=end_date, auto.assign=FALSE,warnings = FALSE))))
}
)
stocks_rtn<-do.call(cbind,stocks_rtn)
colnames(stocks_rtn) <-tickers
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
for (i in 1:10){
assign(paste0(tickers[i]),stocks_mean[i])
}
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10),
stock = c(APA,COG,CVX,MUR,SE,BAC,BLK,COF,GS,MET)
)
View(group)
km <- cclust(c(group$x,group$stock),centers = 2, method = "kmeans")
stocks_mean <- lapply(1:10, function(i){
mean(stocks_rtn[,i])
})
stocks_mean <- as.data.frame(stocks_mean)
colnames(stocks_mean) <- tickers
stocks_mean <- as.matrix(stocks_mean)
stocks_means <- transpose(stocks_mean)
group <- data.frame(g=c(rep(2,5),rep(1,5)),
x=rep(0,10)
)
group <- as.data.frame(cbind(group,stocks_means)
)
View(group)
require(stats)
km <- kmeans(group$stocks_means,centers = 2, nstart = 10)
km
km$cluster
group$x <- km$cluster
View(group)
km$cluster
View(group)
km
table(res = km$cluster , real = group$g)
plot(group$x,group$stocks_means,col=group$g,pch=19,xlab="Real",ylab="Stock Return")
plot(group$x, group$stocks_means, col = km$cluster, pch = 19, xlab = "K-means", ylab="Stocl Return")
shiny::runApp('C:/Users/PedroHenrique/OneDrive/Financial Engineering/Fannie Mae/fannie_mae')
pred_zip_data <- getdata_zip_list(1,14)
source("graphs_functions.R")
source("graphs_functions.R")
setwd("~/")
source("graphs_functions.R")
shiny::runApp('C:/Users/PedroHenrique/OneDrive/Financial Engineering/Fannie Mae/fannie_mae')
setwd("C:/Users/PedroHenrique/OneDrive/Financial Engineering/Fannie Mae/fannie_mae")
runApp()
source("graphs_functions.R")
library("shiny")
library("h2o")
runApp()
pred_zip_data <- getdata_zip_list(1,14)
pred_banks_data <- getdata_banks_list(1,14)
runApp()
